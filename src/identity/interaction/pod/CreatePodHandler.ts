import type { StringSchema } from 'yup';
import { object, string } from 'yup';
import type { ResourceIdentifier } from '../../../http/representation/ResourceIdentifier';
import { getLoggerFor } from '../../../logging/LogUtil';
import type { IdentifierGenerator } from '../../../pods/generate/IdentifierGenerator';
import type { PodSettings } from '../../../pods/settings/PodSettings';
import { BadRequestHttpError } from '../../../util/errors/BadRequestHttpError';
import { joinUrl } from '../../../util/PathUtil';
import { assertAccountId } from '../account/util/AccountUtil';
import type { JsonRepresentation } from '../InteractionUtil';
import { JsonInteractionHandler } from '../JsonInteractionHandler';
import type { JsonInteractionHandlerInput } from '../JsonInteractionHandler';
import type { JsonView } from '../JsonView';
import type { WebIdStore } from '../webid/util/WebIdStore';
import type { WebIdLinkRoute } from '../webid/WebIdLinkRoute';
import { parseSchema, URL_SCHEMA, validateWithError } from '../YupUtil';
import type { PodIdRoute } from './PodIdRoute';
import type { PodStore } from './util/PodStore';

const inSchema = object({
  name: string().trim().min(1).optional(),
  settings: object({
    webId: URL_SCHEMA,
  }).optional(),
});

export interface CreatePodHandlerArgs {
  /**
   * Base URL of the server.
   * Used to potentially set the `solid:oidcIssuer` triple
   * and/or the pod URL if it is a root pod.
   */
  baseUrl: string;
  /**
   * Generates the base URL of the pod based on the input `name`.
   */
  identifierGenerator: IdentifierGenerator;
  /**
   * The path of where the WebID will be generated by the template, relative to the pod URL.
   */
  relativeWebIdPath: string;
  /**
   * WebID data store.
   */
  webIdStore: WebIdStore;
  /**
   * Pod data store.
   */
  podStore: PodStore;
  /**
   * Route to generate WebID link resource URLs.
   */
  webIdLinkRoute: WebIdLinkRoute;
  /**
   * Route to generate Pod ID resource URLs
   */
  podIdRoute: PodIdRoute;
  /**
   * Whether it is allowed to generate a pod in the root of the server.
   */
  allowRoot: boolean;
}

type OutType = {
  pod: string;
  podResource: string;
  webId: string;
  webIdResource?: string;
};

/**
 * Handles the creation of pods.
 * Will call the stored {@link PodStore} with the settings found in the input JSON.
 */
export class CreatePodHandler extends JsonInteractionHandler<OutType> implements JsonView {
  private readonly logger = getLoggerFor(this);

  private readonly baseUrl: string;
  private readonly identifierGenerator: IdentifierGenerator;
  private readonly relativeWebIdPath: string;
  private readonly webIdStore: WebIdStore;
  private readonly podStore: PodStore;
  private readonly webIdLinkRoute: WebIdLinkRoute;
  private readonly podIdRoute: PodIdRoute;

  private readonly inSchema: typeof inSchema;

  public constructor(args: CreatePodHandlerArgs) {
    super();
    this.baseUrl = args.baseUrl;
    this.identifierGenerator = args.identifierGenerator;
    this.relativeWebIdPath = args.relativeWebIdPath;
    this.webIdStore = args.webIdStore;
    this.podStore = args.podStore;
    this.webIdLinkRoute = args.webIdLinkRoute;
    this.podIdRoute = args.podIdRoute;

    this.inSchema = inSchema.clone();

    if (!args.allowRoot) {
      // Casting is necessary to prevent errors
      this.inSchema.fields.name = (this.inSchema.fields.name as StringSchema).required();
    }
  }

  public async getView({ accountId }: JsonInteractionHandlerInput): Promise<JsonRepresentation> {
    assertAccountId(accountId);
    const pods: Record<string, string> = {};
    for (const { id, baseUrl } of await this.podStore.findPods(accountId)) {
      pods[baseUrl] = this.podIdRoute.getPath({ accountId, podId: id });
    }
    return { json: { ...parseSchema(this.inSchema), pods }};
  }

  public async handle({ json, accountId }: JsonInteractionHandlerInput): Promise<JsonRepresentation<OutType>> {
    // In case the class was not initialized with allowRoot: false, missing name values will result in an error
    const { name, settings } = await validateWithError(inSchema, json);
    assertAccountId(accountId);

    const baseIdentifier = this.generateBaseIdentifier(name);
    // Either the input WebID or the one generated in the pod
    const webId = settings?.webId ?? joinUrl(baseIdentifier.path, this.relativeWebIdPath);
    const linkWebId = !settings?.webId;

    const podSettings: PodSettings = {
      ...settings,
      base: baseIdentifier,
      webId,
    };

    // Link the WebID to the account immediately if no WebID was provided.
    // This WebID will be necessary anyway to access the data in the pod,
    // so might as well link it to the account immediately.
    let webIdLink: string | undefined;
    let webIdResource: string | undefined;
    if (linkWebId) {
      // It is important that this check happens here.
      // Otherwise, if the account already has this WebID link,
      // this link would be deleted if pod creation fails,
      // since we clean up the WebID link again afterwards.
      // Current implementation of the {@link WebIdStore} also has this check but better safe than sorry.
      if (await this.webIdStore.isLinked(webId, accountId)) {
        this.logger.warn('Trying to create pod which would generate a WebID that is already linked to this account');
        throw new BadRequestHttpError(`${webId} is already registered to this account.`);
      }

      webIdLink = await this.webIdStore.create(webId, accountId);
      webIdResource = this.webIdLinkRoute.getPath({ accountId, webIdLink });
      // Need to have the necessary `solid:oidcIssuer` triple if the WebID is linked
      podSettings.oidcIssuer = this.baseUrl;
    }

    // Create the pod
    let podId: string;
    try {
      podId = await this.podStore.create(accountId, podSettings, !name);
    } catch (error: unknown) {
      // Undo the WebID linking if pod creation fails
      if (webIdLink) {
        await this.webIdStore.delete(webIdLink);
      }

      throw error;
    }

    const podResource = this.podIdRoute.getPath({ accountId, podId });
    return { json: { pod: baseIdentifier.path, webId, podResource, webIdResource }};
  }

  private generateBaseIdentifier(name?: string): ResourceIdentifier {
    if (name) {
      return this.identifierGenerator.generate(name);
    }
    return { path: this.baseUrl };
  }
}
